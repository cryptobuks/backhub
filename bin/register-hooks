#!/usr/bin/env node
var Octonode = require('octonode');
var optimist = require('optimist');
var userpass = require('../lib/user-pass.js');
var log = require('../lib/log.js');
var Q = require('q');
var argv = optimist.
     usage("Usage: $0 (--repo=owner/repo|--org=org|--user) --url=http://hookurl [--remove]").
     demand(["url"]).
     describe("url","hook url that backub will be listening to (backhub does't care about path, all requests are processed)").
     describe("repo","register the hook [url] on the specified repo (repo == 'owner/name')").
     describe("org","register the hook [url] on all repos owned by the specified organization").
     describe("user","register the hook [url] on all repos owned by the authenticated user").
     describe("remove","remove hook instead of add (no value)").
     argv;

userpass().then(function(info) {
   var client = Octonode.client(info.token || info);
   return chooseRepos(client).
   then(registerEachRepo(client));
}).done();

/**
 * Returns a promise for an array of "owner/repo" strings based on command line
 * arguments.
 */
function chooseRepos(client) {
   var deferred = Q.defer();
   if (argv.repo) {
      log.info("Registering for " + argv.repo);
      deferred.resolve([argv.repo]);
   } else if (argv.user) {
      log.info("Registering for all repos owned by " + argv.user);
      getAllReposFrom(client.me());
   } else if (argv.org) {
      log.info("Registering for all repos owned by " + argv.org);
      getAllReposFrom(client.org(argv.org));
   } else {
      log.error("Must specify --org=name, --repo=user/name, or --user");
      process.exit(1);
   }

   function getAllReposFrom(clientObject) {
      traverseAllPages(clientObject, 'repos').then(function(repos) {
         deferred.resolve(repos.map(getRepoFullName))
      });
   }

   function getRepoFullName(repo) {
      return repo.full_name;
   }

   return deferred.promise;
}

/**
 * Returns a function that will register a hook on a passed array of repos and
 * return a promise for it's completion.
 */
function registerEachRepo(client) {
   var register = getHookRegisterer(client, argv.url, argv.remove);
   return function(repos) {
      var deferred = Q.defer();

      function dequeue() {
         var repo = repos.pop();
         if (!repo) {
            return deferred.resolve();
         }
         register(repo).then(function() {
            dequeue();
         }, function(err) {
            log.error("FAILED while registering hook for " + repo.name + " : " + err);
            dequeue();
         });
      }
      dequeue();

      return deferred.promise;
   }
}

function getHookRegisterer(client, hookUrl, remove) {
   hookUrl += (/\?/.test(hookUrl) ? '&' : '?') + "backhub-hook=1";
   log.info("Getting hook registerer for");
   return function register(repoName) {
      var repo = client.repo(repoName);
      log.info(repo.name + " - begin");
      return findOurHookOnRepo(repo).
      then(function (hook) {
         if (remove && hook) {
            return unRegisterOurHook(repo, hook);
         } else if (!remove && !hook) {
            return registerOurHook(repo)
         } else {
            log.info("Nothing to do");
         }
      })
   }

   function findOurHookOnRepo(repo) {
      return getHooks(repo).then(function(hooks) {
         var hook = findOurHook(hooks, repo);

         if (hook) {
            log.info(repo.name + " - Hook is already registered")
         }
         return hook;
      })
   }

   /**
    * Returns a promise for an array of existing hooks registered on the given
    * repo.
    *
    * @param $repo an octonode 'repo' object
    */
   function getHooks(repo) {
      log.info(repo.name + " - get existing hooks");
      var deferred = Q.defer();
      repo.hooks(function(err, hooks) {
         if (err) {
            log.error(repo.name + " - Error retreiving existing hooks: " + err);
            deferred.reject(err)
         } else {
            log.info(repo.name + " - received existing hooks (" + hooks.length + ")");
            deferred.resolve(hooks)
         }
      })
      return deferred.promise
   }

   /**
    * Note: repo is only passed for logging
    */
   function findOurHook(hooks, repo) {
      for(var i=0; i<hooks.length; i++) {
         var hook = hooks[i];
         var url = hook.config && hook.config.url;
         if (url) {
            log.info(repo.name + " - checking hook:" + url);
            if (/backhub-hook/.test(url)) {
               return hook;
            }
         }
      }
   }

   function registerOurHook(repo) {
      var deferred = Q.defer();
      log.debug(repo.name + " - registering hook:" + hookUrl);
      repo.hook({
         "name": "web",
         "active": true,
         "events": ["push"], // Pretty much only care about updates to branch pointers
         "config": {
            "url": hookUrl
         }
      }, function(err, registered) {
         if (err) {
            log.error(repo.name + " - Error registering hook: " + err);
            deferred.reject(err)
         } else {
            log.info(repo.name + " - Registered hook successfully");
            deferred.resolve(true)
         }
      });
      return deferred.promise;
   }

   function unRegisterOurHook(repo, hook) {
      var deferred = Q.defer();
      log.debug(repo.name + " - removing hook:" + hookUrl);
      repo.client.del("/repos/"+repo.name+"/hooks/" + hook.id, {},
      function (err, status, body, headers) {
         if (err) return deferred.reject(err);
         if (status != 204) return deferred.reject(new Error("HTTP status: " + status));
         log.info(repo.name + " - Removed hook successfully");
         deferred.resolve();
      });
      return deferred.promise;
   }

}

/**
 * Returns a promise for an array of all items from a paginated resource.
 * i.e. client.me().repos() is paginated.
 * Example:
 * traverseAllPages(client.me(),'repos').then(function(reposArray) {});
 */
function traverseAllPages(client, methodName) {
   var deferred = Q.defer();
   var results = [];
   function getPage(page) {
      log.info("Retrieving page " + page);
      client[methodName](page, function(err, data, headers) {
         if (err) {
            log.err("Error: " + err);
            promise.reject(err)
         }
         log.info("Retrieved " + data.length + " results on page " + page);
         results = results.concat(data);

         var linkHeader = headers.link;
         if (/; rel="last"/.test(headers.link)) {
            getPage(page + 1);
         } else {
            log.info("Got " + results.length + " results");
            deferred.resolve(results);
         }
      });
   }

   getPage(1);
   return deferred.promise;
}
